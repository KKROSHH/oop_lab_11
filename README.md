# Конструювання класів з використанням віртуальних функцій
**Мета**: створити, відлагодити та протестувати програму, у якій створити базовий та похідні класи з використанням віртуальних функцій для обробки даних.

## Вказівки до роботи
Відповідно до цієї інструкції вам потрібно у середовищі Visual Studio Code з використанням набору компіляторів GCC створити програму мовою C++ з базовим (батьківським), похідними (дочірніми) класами та віртуальними функціями для обробки даних, також реалізувати відповідні конструктори, деструктори, методи. Використайте динамічний масив (вектор) структур для зберігання введених даних.  Потрібно реалізувати багатофайловий проєкт у середовищі Visual Studio  Code  з описом кожного класу у відповідних парах 
заголовного та виконуваного файлів.
1. Ознайомитися із властивостями віртуальних функцій. Обдумати способи їх використання для створення програм.
2. Вибрати завдання згідно свого варіанту у ДОДАТКУ.
3. Розробити блок-схему алгоритму програми.
4. Реалізувати програму для вводу і виводу даних полів (членів) структур вкладених у клас.

### Короткі відомості
Віртуальна функція в мові С++ — це особливий тип функції, яка, при її виклику, виконує «найдочірніший» метод, який існує між батьківським і дочірніми класами. Ця властивість відома як поліморфізм. Дочірній метод викликається тоді, коли збігається сигнатура (ім’я, типи параметрів і чи є метод константним) і тип повернення дочірнього методу з сигнатурою і типом повернення методу батьківського класу. Такі методи називаються перевизначеннями (або “перевизначеними методами”). Сигнатура віртуального методу дочірнього класу повинна повністю відповідати сигнатурі віртуального методу батьківського класу. Якщо у дочірнього методу буде  інший тип параметрів, ніж у батьківського, то викликатися цей метод не буде.
Якщо функція позначена як віртуальна, то всі відповідні перевизначення теж вважаються віртуальними, навіть якщо біля них явно не вказано ключове слова `virtual`. Однак, наявність ключового слова `virtual` біля методів дочірніх класів послужить корисним нагадуванням про те, що ці методи є віртуальними, а не звичайними. Отже, хорошою практикою є вказування ключового слова `virtual` біля перевизначень в дочірніх класах, навіть якщо це не є строго необхідним. Щоб зробити функцію віртуальною, потрібно просто вказати 
ключове слово `virtual` перед оголошенням функції. Наприклад:
```c++
#include <iostream>
 
class Parent
{
public:
    virtual const char* getName() { return "Parent"; } // 
додали ключове слово virtual
};
class Child: public Parent
{
public:
    virtual const char* getName() { return "Child"; }
};
int main()
{
    Child child;
    Parent &rParent = child;
    std::cout << "rParent is a " << rParent.getName() << '\n';
    return 0;
}
```
Результат:
```
rParent is a Child
```
Оскільки `rParent` є посиланням на батьківську частину об’єкту `child`, то, звичайно, при обробці `rParent.getName()` викликався б `Parent::getName()`. Проте, оскільки `Parent::getName()` є віртуальною функцією, то компілятор розуміє, що потрібно подивитися, чи є перевизначення цього методу в дочірніх класах. І компілятор знаходить `Child::getName()`!
Розглянемо наступний приклад:
```c++
#include <iostream>
 
class A
{
public:
    virtual const char* getName() { return "A"; }
};
 
class B: public A
{
public:
    virtual const char* getName() { return "B"; }
};
 
class C: public B
{
public:
    virtual const char* getName() { return "C"; }
};
 
class D: public C
{
public:
    virtual const char* getName() { return "D"; }
};
int main()
{
    C c;
    A &rParent = c;
    std::cout << "rParent is a " << rParent.getName() << '\n';
 
    return 0;
}
```
Спочатку створюється об’єкт `c` класу `C`. `rParent` — це посилання класу `A`, якому ми вказуємо посилатися на частину `A` об’єкту `c`. Потім викликається метод `rParent.getName()`. Виклик `rParent.GetName()` призводить до виклику `A::getName()`. Однак, оскільки   `A::getName()` є віртуальною функцією, то компілятор шукає «найдочірніший» метод між `A` і `C`. У цьому випадку — це `C::getName()`.
Зверніть увагу, компілятор не викликатиме  `D::getName()`, оскільки наш вихідний об’єкт був класу `C`, а не класу `D`, тому розглядаються методи тільки між класами `A` і `C`.
Результат виконання програми:
```
rParent is a C
```
Не викликайте віртуальні функції в тілі конструкторів або деструкторів. Пам’ятайте, що при створенні об’єкта класу `Child` спочатку   створюється батьківська частина цього об’єкту, а потім вже дочірня! Якщо ви викликатимете віртуальну функцію з конструктора класу `Parent` при тому, що дочірня частина створюваного об’єкта ще не була створена, то викликати дочірній метод замість батьківського буде неможливо, тому що об’єкт `child` для роботи з методом класу `Child` ще не буде створений. У таких випадках в мові C++ викликатиметься батьківська версія методу. Аналогічна проблема існує і з деструкторами. Якщо ви викликаєте віртуальну функцію в тілі деструктора класу `Parent`, то завжди викликатиметься метод класу `Parent`, тому що дочірня частина об’єкту вже буде знищена.
Недоліком віртуальних функцій є те , що обробка і виконання виклику віртуального методу займає більше часу, ніж обробка і виконання виклику звичайного методу. Крім того, компілятор також повинен виділяти один додатковий вказівник для кожного об’єкта класу, який має одну або кілька віртуальних функцій.
Розглянемо складнійший випадок із батьківським класом `Animal`, додавши тестовий код, зробивши метод `speak()` віртуальним:
```c++
#include <iostream>
#include <string>
 
class Animal
{
protected:
    std::string m_name;
 
    /* Ми робимо цей конструктор protected, тому що не хочемо, щоб користувачі мали можливість створювати об'єкти класу Animal     напряму, але хочемо, щоб в дочірніх класах доступ був відкритий */
    Animal(std::string name)
        : m_name(name)
    {
    }
 
public:
    std::string getName() { return m_name; }
    virtual const char* speak() { return "???"; }
};
 
class Cat: public Animal
{
public:
    Cat(std::string name)
        : Animal(name)
    {
    }
 
    virtual const char* speak() { return "Meow"; }
};
class Dog: public Animal
{
public:
    Dog(std::string name)
        : Animal(name)
    {
    }
 
    virtual const char* speak() { return "Woof"; }
};
 
void report(Animal &animal)
{
    std::cout << animal.getName() << " says " << 
animal.speak() << '\n';
}
 
int main()
{
    Cat cat("Matros");
    Dog dog("Barsik");
 
    report(cat);
    report(dog);
}
```
Результат виконання програми:
```
Matros says Meow
Barsik says Woof
```
При обробці `animal.speak()`, компілятор бачить, що метод `Animal::speak()` є віртуальною функцією. Коли `animal` посилається на частину Animal об’єкту `cat`, то компілятор переглядає всі класи між `Animal` і `Cat`, щоб знайти найбільш дочірній метод `speak()`. І знаходить  `Cat::speak()`. У випадку, коли `animal` посилається на частину `Animal` об’єкту `dog`, компілятор знаходить `Dog::speak()`. Зверніть увагу, ми не зробили `Animal::GetName()` віртуальною функцією. Це через те, що `GetName()` ніколи не перевизначається ні в одному з дочірніх класів, тому в цьому немає необхідності.

## ДОДАТОК

### Варіанти завдань

|  № |            Клас              |               Поля класу              |
|----|------------------------------|---------------------------------------|
|  1 | Працівник                    | Касир, вантажник                      |
|  2 | Перевезення                  | Вантажні, пасажирські                 |
|  3 | Місто                        | Промисловий центр, культурний центр   |
|  4 | Літак                        | Пасажирський, транспортний будинку    |
|  5 | Корабель                     | Авіаносець, крейсер                   |
|  6 | Пасажири                     | Поїзд, автобус                        |
|  7 | Транспортний засіб           | Вантажівка, автобус                   |
|  8 | Команда                      | Футбол, баскетбол виходу              |
|  9 | Компанія                     | Будівництво, логістика                |
| 10 | Морські тварини              | Риби, ссавці                          |
| 11 | Сухопутні тварини            | Хижаки, травоїдні                     |
| 12 | Реклама                      | Телебачення, вулична                  |
| 13 | Депозит                      | Прості відсотки, Складні відсотки     |
| 14 | Митець                       | Художник, письменник                  |
| 15 | Друковане видання            | Книга, журнал                         |
| 16 | Екскурсія                    | Музей, театр                          |
| 17 | Подорож                      | Пішохідна, автобусна                  |
| 18 | Геометрична фігура           | Коло, квадрат                         |
| 19 | Упакування                   | Фасування у коробках, рідини у бочках |
| 20 | Змагання                     | Теніс, шахи                           |
| 21 | Тариф                        | З абонплатою, з післяоплатою          |
| 22 | Квиток                       | Поїзд, літак                          |
| 23 | Автомобіль                   | Легковик, вантажівка                  |
| 24 | Перегони                     | Формула 1, Мото Гран-Прі              |
| 25 | Судно                        | Контейнеровоз, танкер                 |
| 26 | Комп’ютер                    | Ноутбук, стаціонарний                 |
| 27 | Будівельна техніка           | Бульдозер, екскаватор                 |
| 28 | Летючі тварини               | Птахи, кажани                         |
| 29 | Сільськогосподарська техніка | Трактор, комбайн                      |
| 30 | Водний спорт                 | Плавання, стрибки з трампліна         |
